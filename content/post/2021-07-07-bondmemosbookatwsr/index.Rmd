---
title: BondMemosBookATWSR
author: Shiwz11
date: '2021-07-07'
slug: bondmemosbookatwsr
categories:
  - Memos
tags:
  - Bonds
---

# 写在前面

该笔记来自于：
Algorithmic Trading Winning Strategies and Their Rationale

by:Ernest P. Chan


# Backtesting and Automated Execution

回测和自动化执行

市面上大部分公开的策略都不会对策略的细节进行详细说明，而这些细节会对策略的盈利能力造成巨大影响，因此，回测策略并找出最优参数就成为了必要。而且，回测有助于发现策略中隐藏的缺陷。

## 回测中常见的错误

### 前视性偏误

Look-ahead bias : 顾名思义，说的是，你的回测程序使用了未来的（明天的）交易价格来决定当前的（今天的）交易价格。一种常见的前视性偏误是在回测中，使用某日的价格高点或低点来决定策略的进入信号。实际上，在该交易日完结之前，我们无法知道该交易日的实际价格高点和低点。这种偏误属于简单的变成上的失误。

### 数据透视偏差和线性模型的妙处

类似于数据过拟合，当你使用了过多的的参数来拟合某段时间特定的市场模式时，虽然拟合效果可能会很好，但是，这种特殊的市场模式在未来很可能不会再出现，就造成了其样本外预测效力极差。这称之为数据透视偏差。

诊断这种偏误的方法也很简单，就是使用样本外数据对模型的预测效果进行评价，但时不幸的是，当模型样本外预测能力表现较差的时候，你真的有决心舍弃之前所有的工作，重新拟合模型吗。恐怕不是，我们可能会针对模型做出这样或那样的改变来使其样本外预测能力和样本内预测能力都说的过去，而实际来看，当你这么做的时候，你实际上是把样本外数据当作样本外数据来用了，这就违反了科学性。

更好的办法是，**交叉验证**。一般来说，非线性模型相比于线性模型会有更多的参数，也有更大的可能引致过拟合。为了避免这种错误，我们通常选择遵循奥卡姆剃刀原则，选择尽可能少的参数。

另一个重要的问题是对分布的假设，我们根据经验知道，正太分布通常并不能很好的描述实际金融数据，但是根据奥卡姆剃刀原则，除非你有强有力的证据表明，应当使用其他分布，那么，你就应该使用最简单的正态分布。

线性模型好就好在它简单，简单并不意味着无效。线性模型生效大多数时候是因为其抓住了市场失灵这一事实。

Daniel Kahneman , the Nobel Prize-winning economist, wrote in hist bestseller *Thinking, Fast and Slow* that "formulas that assign equal weights to all the predictors are often superior, because thay are not affected by accidents of sampling"(Kahneman, 2011)

a simple way to rank a stock:

$$
rank_s = \sum_{i}^{n} sign(i) rank_{s}(i)
$$

### 股票分割和股息调整

股票的分割虽然不会使得受伤的股票的总市值发生变化，但就一份股票来看，会造成价格的骤然下跌。如果不对这种情况进行调整，会造成交易程序产生错误的交易信号。

### 股票数据中的幸存者偏差

如果你的数据库中不包含已经退市的股票，那么就会有极大的可能性被幸存者偏差所蒙蔽。因为你的数据库中的数据都是存活至今的股票，而如果你的交易策略是购买前一日跌幅最大的那只股票，那么，你很有可能会血本无归，因为，该公司情况可能继续恶化，乃至退市。

### 一级与综合股价

一级(primary)股价和综合(Consolidated)股价的问题来源于不同的公司在不同的交易所市场上市。如果使用综合股价来回测模型的话，有极高的概率会夸大策略的收益率。因此，最好的方案是我们有权限连接到实时的Primary Data，但是如果我们实在没有这种权限的话，那就只能自求多福，对回测结果保持谨慎怀疑了。

### 货币交易报价的场所依赖

相比于股票市场，货币市场的交易更加的碎片化（割裂化）。交易员并不会拿当前交易在所有市场上进行综合比价。因此，我们必须使用同一市场的历史数据进行回测并在同一市场应用我们的策略。

还是数据的问题，一般来说，特定交易市场的数据需要特定的权限获得，即使可获得，其数据滞后性问题也必须被考虑在内。因此，找个合适的平台供应商很重要。

### 卖空的限制

理论上可以对市场上任何一只股票进行卖空，但是现实往往存在限制，比如，针对某只股票存在大量卖空，那么你的卖空操作就必须支付相应的费用，这增加了成本，或者更极端的说，甚至可能借不到用以卖空的券。另一种情况是政策限制对某种券的卖空，比如，2008雷曼兄弟破产之后，美国SEC在几个月内禁止了对金融行业股票的卖空操作。

我们的策略必须考虑以上情形，否则，虽然可以得到美好的纸面收益率，但却是镜花水月，不可实现。

另一个对卖空的限制是所谓的“报升规则”(Uptick Rule)，指的是，卖空交易不能以低于当时最佳卖盘价格(即，卖盘中最低价格)进行，该规则限制了在价格下跌时对价格的打压。另外还需注意熔断机制等补充规则的影响。

### 期货连续合约

创建一个连续合约的第一步是在给定数个展期日的情况下，先将近月交割合约的价格组合起来。但这种情况下，在展期日前一天和展期日当天就会出现一个明显的价格gap，而这会造成回测中收益的错误。

### 期货收盘价和结算价

一般来说，供应商提供的期货收盘价实际上是结算价，而不是当天最后一笔期货交易的成交价。一般来说，结算价和当前最后一笔交易的成交价并不一样。需要注意的是，有些数据供应商会提供逐笔交易的数据，这种数据是真实的交易价格。在这种情况下，收盘价将会是最后一笔交易的价格。

大多数情况下，我们应当使用结算价，因为，如果你在临近收市的时候交易的话，改价格最为接近你的成交价格。后面的不太明白了


如果你构建一个日间利差交易策略或者使用日间期货价格来回测你的利差策略，那么，你将会用到买卖双方的bid和ask价格；当利差为负的时候，你将会需要该利差数据的日间原始数据。

不同券最后一笔的利差策略需要注意一点就是，他们的最后一笔交易发生时间往往是不同步的，如果相差较多，可能对利率收益的实现产生影响。

市场间利差策略的一个需要注意的点是，如果合约是在不同的交易所交易的，那么，他们可能会有不同的收市时间，因此使用其收盘价来做利差策略是不可行的。总之，要注意其交易时间的同步性。

### 回测的统计显著性：假设检验

回测中的统计检验遵循以下步骤：

1. 基于有限样本，我们首先计算出待检验指标，比如某策略的日平均收益；

2. 原假设：基于无限样本的真实日平均收益为0；

3. 假设日收益的分布已知，并且又零均值；

4. 然后根据假设的概率分布计算出p值，来决定是否拒绝原假设，并确定其显著性水平。

其中，比较麻烦的是第三步，怎么确定其概率分布。一个简单的做法是，假设其为高斯分布，然后，根据样本的标准差估算其分布标准差，一般来说，有高夏普比率更容易得到统计显著的结果。另一种方法是使用蒙特卡洛模拟出历史价格数据，并将模拟结果代回我们的策略来推断出收益的概率分布。

第三种方法由Andrew Lo and his collaborators (Lo, Mamaysky, and Wang, 2000)提出，在该方法中，不模拟价格数据，而是根据真实交易数据产生出模拟的交易数据。很显然的一点是，三种方法得出的概率分布进行的假设检验很可能会得出不同的结果。

**Example 1.1**：

该例子针对第六章的动量策略实施了上述三种假设检验。若策略产生12个月的正收益，则购买期货并持有一个月。

- 第一种检验方法

该方法很简单，假设数据服从零均值的高斯分布，标准差来自于样本数据。假设`ret`是一个$T\times 1$的array。使用matlab计算其统计量如下：

```{matlab}
# matlab and R
mean(ret) / std(ret)*sqrt(length(ret))
```

- 第二种检验方法

该方法针对期货合约产生出一系列模拟的每日汇报数据（请注意，不是模拟策略的收益率）。模拟出的数据相比于真实数据会有相同的均值、标准差、峰度和偏度。如果我们测试发现我们的策略在模拟的数据中相比于真实数据中，能产生一样好甚至更好的收益，那么**很不幸**，这说明，我们的策略没有抓住真实数据的任何趋势和序列相关性。而其之所以能盈利仅仅是因为运气。

使用matlab来模拟出之前所述的数据，然后，我们使用模拟出的收益数据模拟出价格数据，最后，我么在模拟出的数据上跑10000次我们的策略，并观察其收益率。统计出有多少次，其收益率大于等于真实数据上的收益率。

```{matlab}
# matlab
clear;

% load('../Data/inputDataOHLCDaily_20120511', 'syms', 'tday', 'cl');
load('inputDataOHLCDaily_20120511', 'syms', 'tday', 'cl');
idx=strmatch('TU', syms, 'exact');

tday=tday(:, idx);
cl=cl(:, idx);

lookback=250;
holddays=25;

longs=cl > backshift(lookback, cl)  ;
shorts=cl < backshift(lookback, cl) ;

pos=zeros(length(cl), 1);

for h=0:holddays-1
    long_lag=backshift(h, longs);
    long_lag(isnan(long_lag))=false;
    long_lag=logical(long_lag);
    
    short_lag=backshift(h, shorts);
    short_lag(isnan(short_lag))=false;
    short_lag=logical(short_lag);
    
    pos(long_lag)=pos(long_lag)+1;
    pos(short_lag)=pos(short_lag)-1;
end

marketRet=(cl-backshift(1, cl))./backshift(1, cl);
marketRet(~isfinite(marketRet))=0;

ret=backshift(1, pos).*marketRet/holddays;

ret(isnan(ret))=0;

% Gaussian hypothesis test
fprintf(1, 'Gaussian Test statistic=%4.2f\n', mean(ret)/std(ret)*sqrt(length(ret)));
% Gaussian Test statistic=2.93

% Randomized market returns hypothesis test
moments={mean(marketRet), std(marketRet), skewness(marketRet), kurtosis(marketRet)};
numSampleAvgretBetterOrEqualObserved=0;
for sample=1:10000
    marketRet_sim=pearsrnd(moments{:}, length(marketRet), 1);
    cl_sim=cumprod(1+marketRet_sim)-1;
    
    longs_sim=cl_sim > backshift(lookback, cl_sim)  ;
    shorts_sim=cl_sim < backshift(lookback, cl_sim) ;
    
    pos_sim=zeros(length(cl_sim), 1);
    
    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag);
        
        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos_sim(long_sim_lag)=pos_sim(long_sim_lag)+1;
        pos_sim(short_sim_lag)=pos_sim(short_sim_lag)-1;
    end

    
    ret_sim=backshift(1, pos_sim).*marketRet_sim/holddays;
    ret_sim(~isfinite(ret_sim))=0;
    
    if (mean(ret_sim)>= mean(ret))
        numSampleAvgretBetterOrEqualObserved=numSampleAvgretBetterOrEqualObserved+1;
    end
end

fprintf(1, 'Randomized prices: p-value=%f\n', numSampleAvgretBetterOrEqualObserved/10000);
% p-value=0.027500


% Randomized entry trades hypothesis test

numSampleAvgretBetterOrEqualObserved=0;
for sample=1:100000
    P=randperm(length(longs));
    longs_sim=longs(P);
    shorts_sim=shorts(P);
    
    pos_sim=zeros(length(cl), 1);

    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag);
        
        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos(long_sim_lag)=pos(long_sim_lag)+1;
        pos(short_sim_lag)=pos(short_sim_lag)-1;
    end

    ret_sim=backshift(1, pos_sim).*marketRet/holddays;

    ret_sim(isnan(ret_sim))=0;
    
  
    if (mean(ret_sim)>= mean(ret))
        numSampleAvgretBetterOrEqualObserved=numSampleAvgretBetterOrEqualObserved+1;
    end

end
fprintf(1, 'Randomized trades: p-value=%f\n', numSampleAvgretBetterOrEqualObserved/100000);
```


书中的结果显示，在10000次模拟中，有1166次的平均策略收益大于实际观测的平均收益。这也就意味着我们只能以88%的概率拒绝原假设。

- 第三种检验方法

matlab程序如下：

```{matlab}
numSampleAvgretBetterOrEqualObserved=0;

for sample=1:100000
    P = randperm(length(longs));
    longs_sim=longs(P);
    shorts_sim=shorts(P);

    pos_sim=zers(length(c1), 1);

    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag)；

        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos(long_sim_lag)=pos(long_sim_lag)+1;
        pos(short_sim_lag)=pos(short_sim_lag)-1;
    end

    ret_sim=backshift(1, pos_sim).*marketRet/holiddays;

    ret_sim(isnan(ret_sim))=0;

    if (mean(ret_sim) >= mean(ret))
    numSampleAvgretBetterOrEqualObserved=...
      numSampleAvgretBetterOrEqualObserved+1;
    end

end

```


## 什么时候不用进行回测

在前面的文章中作者极力推荐对策略进行回测，而事实是，有些策略实在是太垃圾，因此，没必要浪费时间对其进行回测。

- Example 1:一个策略，有30%的年化收益率，0.3的夏普比率，两年的最大回撤持续期。

较低的夏普比率伴随着较长的回撤持续期意味着你的策略很不稳定。其产生较高的收益很可能是因为巧合，在世纪的交易中不可复现。另一种可能是，高的收益来源于数据的过拟合，过高的回撤持续期八成会导致该策略通不过交叉验证。

因此，记住，对于以下两种策略不要考虑：1.收益率过高而夏普比率很低；2.策略最大回撤持续期比你能承受的最长期限还长。

- Example 2:一个在2007年的原油期货多头策略，回报率20%，夏普比率1.5。

该策略的实际表现还不如最简单那的购买并持有策略，因此，我们一定要选择一个合适的Benchamrk.

- Example 3: 低买高卖策略，在年初买进10只被低估的股票，并持有一年，回测中，其在2001年的收益率388%。

当我们审视该回测结果的时候，我们应该考虑以下问题：该回测结果是否使用了存在幸存者偏差的数据库，也就是说，我们使用的数据库是否包含了退市的股票；如果包含了该数据，那么该策略最有可能的收益是-100%。

- Example 4: 一个神经网络交易策略，有100个节点，回测中的夏普比率为6。

即使对神经网络不甚了解，有一点是明确的，节点的数目和模型的参数数量是正相关的，100个节点必然会导致模型的过拟合。该模型对样本外数据会毫无预测能力。

- Example 5: 一个高频的E-mini SP500期货交易策略，回测中有200%的收益，夏普比率为6，每手的平均持有期限是50秒。

高频交易策略的表现取决于交易中使用的订单类型。更进一步的说，高频策略的表现取决于市场的微观结构，即使我们有整个市场的交易数据，策略的实际表现依然受其他市场参与者的巨大影响。

更重要的是，在实际的交易中，你的高频策略八成会改变其他市场参与者的行为（海森堡不确定原理），因此，对高频策略的回测要尤其谨慎。

人生苦短，没必要浪费时间在垃圾策略上。

## 回测是否对未来收益具有预测力

即使我们的策略在回测中表现除了较高的统计显著性，其对未来的预测能力建立在以下假设上：在未来，价格的时间序列的性质不发生变化。而实际上，该假设往往不成立，一国的经济形势会变；一家公司的发展形式也会变；金融市场的结构也会发生变化。而这些变化往往会改变策略的表现，因此需要时刻考虑以上因素。

## 选择一个好的量化平台

选择一个合适的平台有以下判断标准

### 你自身的编程能力

总之就是避免使用Excel

总之，主流的平台都有自己的API，甚至自己的IDE。

### 能否用同一套程序来回测和执行

答案是看你的使用的平台，具体情况具体说。

总之，就是有钱的话，能够购买到商业平台，各种特性都支持，而开源的平台各有各的特点。

### Does the Platform Have Complex Event Processing

# 均值回归策略基础

在金融时间序列中是否广泛存在均值回归现象呢？很遗憾，并不是，如果是的话，那这个世界就简单太多了。大部分的价格数据服从随机游走。少部分的价格数据是平稳的，他们有均值回归特性。

幸运的是，多个时间序列可能会存在协整关系，而针对存在协整关系的时间序列，我们的居住回归策略依然有其用武之地。

## 均值回归和平稳性

数据的均值回归特性和平稳性是数据的两个方面，视角不同，所用的测试方法也不同。

一个时间序列的均值回归特性意味着，该序列在下一期的值和当期价格和平均价格的差成比例。我们用ADF检验对该特性进行检验，实际上是检验了比例变量的系数是否为0.

而从平稳性角度来看，一个时间序列是平稳的意味着，该时间序列的log值的方差相比于随即游走的方差增加的较慢。也就是说，他们的方差是一个关于时间$t$的次线性函数。该次线性函数我们通常用$\tau^{2H}$来逼近，其，$\tau$ is the so-called time separating two price measurements, $H$是所谓的赫斯特指数，若时间序列是平稳的，则$H$应当是小于0.5的（若序列是一个随即游走，则其应当等于0.5）。Variance Ratio检验可用来检验原假设：赫斯特指数是0.5。

### 增广的DF检验

我们使用一个线性模型来描述平稳的价格变化序列：

$$
\Delta y(t) = \lambda y(t-1)+\mu +\beta t +\alpha_1\Delta y(t-1) +\dots + \alpha_k \Delta y(t-k) +\epsilon_t
$$

其中：

$\Delta y(t) \equiv y(t) - y(t-1)$

ADF检验实际上就是检验原假设：$\lambda =0$.

若拒绝原假设意味着序列不是随机游走，当前期的y值对下一期的y值有影响。

检验统计量：

$$
\lambda/SE(\lambda)
$$

实际上，不用管这些，只管用就行了。

**Example: 均值回归中的ADF检验(Using Matlab)**

matlab 开源程序包提供了`adftest`函数来进行adf检验。

```{matlab}
# 真用到matlab的时候再看手册不迟
results=adf(y,0,1)
prt(results)
```

### 赫斯特指数和方差比检验

The speed of diffusion can be calculated by the variance:

$$
Var(\tau) = <|z(t+\tau) - z(t)|^{2}>
$$

$z = log(y)$;

$\tau$:arbitrary time lag;

$<\dots>$ : average over all $t^{,}$ s


### Half-Life of Mean Reversion


![**半条命？？**](https://v2fy.com/asset/0i/ChineseBQB/011Dog_%E7%8B%97%F0%9F%90%B6BQB/%E7%8B%9700022-%E6%89%8B%E5%8A%A8%E7%8B%97%E5%A4%B4.gif)

统计上的显著性实际上要求比较严格，一般来说，要求至少90%的显著性；而在实际应用中，哪怕显著性更低些，也不意味着我们的策略不能盈利。上面式子中的$\lambda$参数还有另一种解释，即，it's a measure of how long ti taks for a price to mean revert.

我们把本章最开始的那个线性模型取差分形式并用无穷小来逼近，即可得到以下形式(Ornstein-Uhlenbeck formula)：

$$
dy(t) = (\lambda y(t-1) + \mu)dt +d\epsilon 
$$

$d\epsilon$ : 高斯分布的噪声。

巴拉巴拉，使用差分形式重写方程的好处在于其可以给出$y(t)$的期望值的一个解析解。

$$
E(y(t)) = y_0 exp(\lambda t) - \mu / \lambda (1-exp(\lambda t))
$$

在一个均值回归（平稳）过程中，$\lambda$是负的。如果我们发现其为正的，那么就不应当应用均值回归策略。另一点，如果$\lambda$非常接近0那么，half-life将会非常的长，那么，在给定的时间里，我们将不能完成足够的交易轮次，这就意味着，该策略赚不了钱。

**Example: 2.4 计算均值回归策略中的Half Life**

> 所以这是半条命还是半衰期。。。

![](https://v2fy.com/asset/0i/ChineseBQB/043Altman_%E5%A5%A5%E7%89%B9%E6%9B%BCBQB/%E5%A5%A5%E7%89%B9%E6%9B%BC00285-%E5%B0%8F%E5%B0%8F%E7%9A%84%E5%87%B9%E5%87%B8%E6%9B%BC%E8%84%91%E8%A2%8B%E8%A3%85%E6%BB%A1%E4%BA%86%E5%A4%A7%E5%A4%A7%E7%9A%84%E7%96%91%E6%83%91.jpg)

之前的例子中，我们认识到USD.CAD在90%的显著性水平上是一个不平稳的序列，但这并不意味着我们不能对该序列使用均值回归策略。因为均值回归策略其实对数据的要求并没有那么高。我们在此计算出其Half Life of mean reversion 来决定其是否合适应用均值回归策略。

**因变量**：$y(t) - y(t-1)$;

**自变量**: $y(t-1)$。

跑个OLS回归。相应命令在`jplv7`包中，MATLAB的统计工具箱中的`regress`也可以实现。

```{matlab}
ylag = lag(y,1); % lag is a function in the jplv7
deltaY = y - ylag;
deltaY(1) = []; %Regression functions cannot handle the NaN in the first bar of the time series
ylag(1) = [];
regress_result = ols(deltaY, [ylag ones(size(ylag))]);
halflife=-log(2)/regress_results.beta(1);
```

### 一个线性的均值回归策略

# Chapter 3 均值回归策略实操

实操中，我们并不需要真正严格的平稳关系或者协整关系，如果我们挖掘的足够深， 我们就能够发现季节性的或者短期的均值回归特性（季节性均值回归特性意味着 我们的数据只在特定的时间段或者特定的条件下才会呈现出均值回归特性）。而且， 并不是所有的平稳序列都会产生较大的利润，至少当其均值回归的Half-Life过长的时候 该策略不会有什么好收益。

在本章，我们呈现一个虽然简单但却实用的策略：Bollinger Bnads。我们呈现了其 特性以及在估计Hedge Ratio and Mean Price的估计中，卡尔曼滤波的使用。

## Trading Pairs Using Price Spreads , Log Price Spreads, or Ratios

在第二章，我们使用单位资产篮子的价格作为我们的交易信号，该价格为原始价格的一个加权平均。其权重来自于一个线性回归或者Johansen检验之中，其公式如下：

$$
y = h_1 y_1 + h_2 y_2 + \dots + h_n y_n  \quad (3.1)
$$

$$
y = y_1 - h y_2 \quad （3.2）
$$

有些时候，我们会发现，价格的线性组合依然是不平稳的，其log值可能是平稳的，如下：

$$
log(q) = h_1 log(y_1) + h_2 log(y_2) + \dots + h_n log(y_n) \quad (3.3)
$$

其中h依然是来自于某个神秘的回归或者Johansen检验的特征向量。对于（3.3）我们该怎么解释呢，我们对于上式取一阶时间上的差分：

$$
\Delta log(q) = h_1 \Delta log(y_1) + h_2 \Delta log(y_2) + \dots h_n \Delta log(y_n) \quad (3.4)
$$

其中：

$$
\Delta log(x) \equiv log(x(t)) - log(x(t-1)) = log(x(t)/x(t-1)) 
$$

当x的变化较小的时候，上式约等于$\Delta x /x$.

在式(3.4)中，我们可以把h的值设置为各资产的价格，So, we can set the market value of each asset to h, so, we can interpret q as the market value of a protfolio of assets with price $y_1, y_2, \dots y_n$ and with constant capital weights $h_1, h_2, \dots h_n$

当我们的资产组合中的价格序列并没有协整关系的时候，使用比率($y_1 / y_2$ )有着天然的优势。比如说，价格$A=10$价格B=100,当其价格都分别上涨10倍的时候我们发现其比率是不变的，而当我们使用绝对量的时候哦就可能得出结论：该序列是不平稳的。

换句话说，如果你的两个资产标的的价格并存在协整关系，但是你相信在某一段时间里，该两个序列依然存在均值回归关系，那么你就可以尝试使用比率，或许其效果会比使用绝对量和log值更好。

还有另外一种情形最好使用比值，we often need to use a dynamicallly changig hedge ratio to construct the spread.But we can dispense with this trouble if we use the ratio as a signal in this sitration.但是需要注意的是，价格比例并不总是比绝对值利差和log值利差表现更好，需要具体情况具体判断。

有些市场，比如货币市场，是有现成的比率数据的（应该就是汇率），但是另外一些市场并没有提供现成的比率数据，即使如此，在这类市场上，比率方法依然值得一试。

**Example .1: Trading Price Spread, Log Price Spread, and Ratio**:

前面的例子2.5和2.8中，我们对ETFs GLD and USO演示了均值回归策略，此处，我们将此策略分别应用到price spread, log price spread and ratio上来对比其效果。

一些投资者相信以下逻辑：当石油价格上升的时候，会推升通货膨胀，因而导致金价的上涨。但是实际上，对石油价格和金价进行检验，发现两者并不存在协整关系。我们在此探究，他们两者之间是否存在稳定的短期关系以至于使得均值回归策略有利可图。

1.  首先，我们使用price spread来作为我们的交易信号

在这种情况下，我们需要定期重新计算出对冲比率using a short look-back period in order to adapt the changing levels of the ETFs.

我们使用OLS回归或者Johansen检验的特征向量来得出我们的对冲比率。假设GLD的价格为一个$T\times1$的array x;USO的价格序列形状相同为y。请记住，我们常说的"spread"等于$USO=hedgeRatio*GLD$等于单位资产组合的价格（程序中使用yport代表）。

```{matlab}
% lookback period for calculating the dynamically changing 
% hedge ratiod

lookback=20;
hedgeRatio=NaN(size(x, 1), 1);
for t=lookback:size(hedgeRatio, 1)
  regression_result=ols(y(t-lookback+1:t),  ...
    [x(t-lookback+1:t) ones(lookback, 1)]);
  hedgeRatio(t) = regression_result.beta(1);
end

y2 = [x,y];
yport=sum([-hedgeRatio ones(size(hedgeRatio))].*y2, 2);
```

将该序列画图发现，其至少看起来是平稳的。我们现在来探究，能否实现一个盈利的举止回归策略。

其中，the $T\times 2$ positions array represents the market value (in dolllars) for each of the constituent ETFs we should be invested in.

```{matlab}
numUnits = -(spread-movingAvg(spread, lookback)) ...
  ./movingStd(spread, lookback);
positions=repmat(numUnits, [1 size(y2, 2)]).*[hedgeRation ...
  -ones(size(hedgeRatio))].*y2; pn1 = sum(lag(positions, ...
  1).*(y2-lag(y2, 1))./lag(y2, 1), 2); % daily P and L of the strategy
  
ret = pn1 ./ sum(abs(lag(positionis, 1)), 2); % return is P and L
% divided by gross market value of portfolio
```

虽然GLD和USO无论如何也是不协整的，但是我们在此策略中实现了10.9%的年化收益和0.59的夏普比率。

2.  现在尝试log price

源码存放在LogPriceSpread.m中，其中与PriceSpread.m不同的两行如下：

```{matlab}
regression_result = ols(log(y(t-lookback+1:t)), ...
  [log(x(t-lookback+1:t)) ones(lookback, 1)]);
  
% the other line

yport = sum([-hedgeRatio ones(size(hedgeRatio))].*log(y2), ...
  2);
% the net market value of the portfolio is the same as the "spread"
```

使用log price 实现了9%的年化收益和0.5的夏普比率。明显不如price spread 的效果。

3.  Ratio as the signal

该部分的源码在`Ratio.m`中，通过图3.2可以看到，该数据极端不平稳，其年化收益为负值。

```{matlab}
lookback = 20; % lookback is set arbitrarily
ratio = y./x;
ratio(1:lookback)=[]; % Removed to have same test seet as
% price spread and log price spread stratigies
x(1:lookback)=[];
y(1:lookback)=[];

% Apply a simple linear mean reversion strategy to GLD-USO
numUnits = -(ratio-movingAvg(ratio, lookback)) ...
  ./movingStd(ratio, lookback); positions = repmat(numUnits, ...
  [1 2]).*[-ones(size(x, 1), 1) ones(size(x, 1), 1)];
  pn1=sum(log(positions, 1).*([x y] - lag([x y], 1)). ...
  /lag([x y], 1), 2); ret=pn1 ./ sum(abs(lag(positions,1)), 2);
```

## 布林线（带）(BOLL 指标)

目前展示的均值回归策略只是**线性策略**：simply scale the number of units invested in a stationary unit portfolio to be proportional to the deviation of the market value (price) of the unit portfolio from a moving average.该策略不需要任何参数因此，也绝对不会出现过拟合的情况。该方法虽然能够判断对于一个给定的资产组合均值回归策略能否盈利，但是却并不能实际应用。因为我们事先并不知道资产篮子有多大。

此时，就轮到布林线登场了。我们可以等到价格偏离均值的水平超过其entryZscore标准差的时候再入场。 entryZscore是特定训练集的一个自由参数，均值和标准差指的是指定某一长度的回溯期之后计算的出的。回溯期长度也是一个需要优化的参数，或者可以被简单的设定为mean reversion 的 Half-life.

We can exit when the price mean-reverts to exitZscore standard deviations from the means, where $exitZscore < entryZscore$。若$exitZsocre=0$，这意味着当价格回归到均值的时候我们再退场。if $exitZsocre=-entryZsocre$, we will exit when the price moves beyond the opposite band so as to trigger a trading signal of the opposit sign.

**Example 3.2**:我们依然使用Paire GLD-USO we discussed above

此处，我么设定$entryZscore = 1$， $exitZscore = 0$，源码位于`bollinger.m`中。entry Signal data `longsEntry` and `shortsEntry` 是$T \times 1$的`bool`类型变量。

`numUnitsLong`: $T\times 1$ 的array，对于其中的某一元素，若我们收到一个进入信号，则元素值为1，若收到退出信号，则为0。某天未产生信号，则使用前一天的值来填补Na。

```{matlab}
% Bollinger band strategy
entryZscore=1;
exitZscore=0;

zScore=(yport-movingAvg(yport, lookback)) ./movingStd(yport, lookback);
longsEntry=zSCORE < -entryZscore;
% a long position means we should buy EWC
longsExit=zScore >= -exitZscore;

shortsEntry=zScore > entryZscore;
shortsExit=zSCORE <= exitZscore;

numUnitsLong=NaN(length(yport), 1);
numUnitsShort=NaN(length(yport), 1);

numUnitsLong(1) = 0;
numUnitsShort(longsEntry) = 1;
numUnitsLong(longsExit) = 0;
numUnitsLong=fillMissingData(numUnitsLong);

numUnitrsShort(1) = 0;
numUnitsShort(shortsEntry)=-1;
numUnitsShort(shortsExit)=0;
numUnitsShort=fillMissingData(numUnitsShort);

numUnits = numUnitsLong + numUnitsShort;
```

Bollinger Band策略年化有17.8，夏普比率0.96。

## Does Scaling-in Work?

Sccaling-in or averaging-in, 当某资产价格偏离其均值越来越远的时候，其获利的可能性越大。在这种情况下，我们有动机增加该资产的配置盘。即使，该资产的价格不是真正平稳的，其价格也不会真的回归到均值，我们依然能够使用均值回归策略来谋利。

(Schoenberg and Corwin, 2010) proved that entering or exiting at two or more Bollinger bands is never optimal; that is, you can always find a single extry/exit level that will generate a higher average return in a backtest.

假设某期货合约近期跌到了价格$L_1$，其有p的概率继续下跌到$L_2$，然后回复到价格F； 有$1-p$的概率回升到一个最终价格F。假设我们手上的资金仅够我们投两手。

1.  在价格为$L_1$的时候 all-in。

2.  在价格为$L_2$的时候 all-in。（若价格达不到$L_2$，则我们啥也不投）

3.  average-in,价格达到$L_1$的时候我们投一手，价格达到$L2$的时候，我们投一手。

当价格达到F的时候我们exit all （不是average out）。三种情况下的期望收益为：

1.  $2(1-p)(F-L_1)$;

2.  $2p(F-L_2)$

3.  $p[(F-L_1)+(F-L_2)] + (1-p)(F-L_1) = (F-L_1) +p(F-L_2)$

我们令$\hat{p} = (F-L_1)/(F-L_2)$，若$p < \hat{p}$则方法1更赚钱，反之方法二。但是现实生活中p永远不会是一个确定的常数，而且，虽然方法三并不是最赚钱的，但是在现实中其却可能有最好的样本外表现。

## Kalman Filter as Dynamic Linear Regression

现实中，很少有数据是平稳的，那么我们怎么估计其对冲比率呢。(Montana, Triantafyllopoulos, and Tsagaris, 2009)。

卡尔曼滤波是一个线性算法，其根据近期观测到的值来更新某些隐藏变量的值。其假设观测变量是隐藏变量的一个线性函数，同时，隐藏变量在t时刻的值是其$t-1$时刻的值的函数。默认假设噪声服从高斯分布。当我们假设数据噪音服从高斯分布的时候，卡尔曼滤波方法不失为估计参数的一个很好的方法。

For every application of Kalman Filtering, we need to first figure out what these variables and matrices are:

-   Obervable variable (vec)

-   Hidden variable (vec)

-   Stat transition model (mat)

-   Observation model (mat)

$$
y(t) = x(t) \beta (t) + \epsilon(t) \quad (Measurement\ equation) \quad (3.5)
$$

$y$:价格序列；

$x$: 另一资产的价格序列；

$\beta$: 隐藏变量------对冲比率，$2\times 1$的向量，包含slope and intercept；

$\epsilon$ : 方差为$V_{\epsilon}$的高斯分布的噪声。

接下来，我们假设$\beta$在t时刻的值等于其在$t-1$时刻的值加上一个噪声：

$$
\beta(t) = \beta (t-1) + w(t-1), \quad (State transition) \quad (3.6)
$$

$w$ : 方差为$V_{w}$的高斯噪声。

使用卡尔曼滤波我们不仅能够获得两资产之间动态的对冲比率，还能获得利差的"移动平均值"。其另一个副产品就是能够产生对观测值预测的标准差的估计，which we can use in place of the moving standard deviation of a Bollinger band.

我们不必关心其数学推导关系，了解其性质，用就完了。

**Example 3.3: Kalman Filter Mean Reversion Strategy**

使用前面例子2.7中的EWA-EWC资产组合数据来演示卡尔曼滤波的实现过程。

```{matlab}
% Augment x with ones to accommodate possible offset in the regression between y vs x
x = [x ones(size(x))];

delta=0.0001;
% delta=0 allows no change (like traditional linear regression)
yhat=NaN(size(y));  % measurement prediction
e=NaN(size(y));  % measurement prediction error
Q=NaN(size(y));  % measurement prediction error variance

% FOr clarity, we denote R(t|t) by P(t).
% initialize P and beta.
P=zers(2);
beta=NaN(2, size(x, 1));
Vw=delta/(1-delta)*diag(ones(2, 1));
Ve=0.01;

% Initialize beta(:, 1) to zero
beta(:, 1)=0;
for t=1:length(y)
  if (t>1)
    beta(:, t)=beta(:.t-1);  % state prediction.
      % Equation 3.7
  end
  
  yhat(t) = x(t, :)*beta(:, t);  % measurement prediction.
    % Equation 3.9
  Q(t) = x(t, :)*R*x(t, :)' + Ve;  %measurement variance
    % prediction. Equatioin 3.10
  
  % Observer y(t)
  e(t) = y(t) - yhat(t);  % measurement prediction error
  
  K=R*x(t, :)' / Q(t);  % Kalman gain
  
  beta(:, t) = beta(:, t) + K*e(t);  % State update
    % Equation 3.11
  P=R-K*x(t, :)*R;   % State covariance update. Equation 3.12
  
End
```


![FIGURE 3.5 Kalman FIlter Estimate of the Slope between EWC(y) and EWA(x)](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-3-5.png)

![Kalman Filter Estimate of the Intercept between EWC(y) and EWA(x) ](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-3-6.png)

我们可以使用从卡尔曼滤波中计算得来的结果构造策略。The measurement prediction $e(t)$ (previouls called the forecast error for $y(t)$ given observation at $t-1$) is none other than the deviation of the spread EWC-EWA from its pridicted mean value, and we will buy this spread whe the deviation is very negative, and vice versa is it is very positive.

我们将$e(t)$和$\sqrt{Q(t)}$画图(Figure 3.7)，发现，在$\delta$很小的时候，$\sqrt{Q(t)}$变化也很慢。

```{matlab}
# The matlab code for determining the entry and exit signals follows
y2=[x(:, 1) y]
longsEntry=e < -sqrt(Q);  % a long position means we should buy EWCC
longsExit=e > -sqrt(Q);

shortsEntry=e > sqrt (Q);
shortsExit=e < sqrt(Q);
```

![Figure 3.7 Measurement Prediction Error e(t) and Standard Deviation of e(t)](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-3-7.png)

该策略可实现26.2%的年化，夏普比率2.4。其cumulative returns 在Figure 3.8.

![Figure 3.8 Cumulative Retures of Kalman Filter Strategy on EWA-EWC](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-3-8.png)

## Kalman Filter as Market-Making Model

这里我们展示另一个使用卡尔曼滤波的均值回归过程。在此例子中，我们只关心其中一个价格序列，对于两个协整序列之间的对冲比率，我们并不关心。和以前一样的是，我们依然需要找到价格序列的均值和标准差。

The measurement equation in this case is trivial:

$$
y(t) = m(t) +\epsilon (t) \quad (Measurement equation) \quad (3.14)
$$

transition equaiton:

$$
m(t) = m(t-1) +  w(t-1) \quad (State transition) \quad (3.15)
$$

state update equation:

$$
m(t|t) = m(t|t-1)K(t)(y(t)-m(t|t-1)) \quad (State update) \quad (3.16)
$$

variance of the forecast error:

$$
Q(t) = Var(m(t)) + V_{e} \quad (3.17)
$$

Kalman gain:

$$
K(t) = R(t|t-1)/(R(t|t-1) +V_{e}) \quad  (3.18)
$$

state variance update:

$$
R(t|t) = (1-K(t))R(t|t-1) \quad (3.19)
$$

We denote the trade size as $T$ and the benchmark trade size as $T_{max}$, then $V_e$ can have the form:

$$
V_e = R(t|t-1)[\frac{T}{T_{max}} - 1]
$$

若$T=T_{max}$，则我们观测到的价格序列里就不存在不确定性了，此时，Kalman gain就是1，同时，价格均值的估计$m(t)$恰好等于观测值。

## The Danger of Data Error

额。。。平生最恨data error。Thomas Falkenberry (2002) has written more on data cleaning issues.

## 总结

**Some Key Points**:

- Do you want to construct a mean-reverting portfolio with a fixed number of shares during the duration of a trade? Use price series to determine the hedge ratios.

- Do you want to construct a mean-reverting portfolio with fixed market values for each constituent during the duration of a trade? Use log price series to determine the hedge ratios.

- Ratio, instead of spreads, is often a good indicator for trading currency pairs.

- afraid that the hedge ratio, mean and standard deviation of a spread may vary in the future? Use a moving look-back period or the Kalman Filter.

- A practical implementation of a linear trading strategy is the Bollinger bands with scaling-in.

- Scaling-in may not be optimal in backtests but is often useful for live trading where volatilities and probabilities do change.

- Do you want to dynamically update the expected price of an instrument based on its latested trade (price and size)? Use the Kalman Filter.

- Data errors can inflate the backtest result of mean-reverting strategits but not momentum strategies.

- Strategies based on spreads are particularly sensitive to small data errors, whether in backtest or live trading.

# Chapter 4 Mean Reversion of Stocks and ETFs

理论上来说，股票市场上的众多股票受相同的经济因素的影响，因此应该可以找到不少存在协整关系的股票。但，这也只是理论上，现实的应用存在诸多困难。

在通常情况下，大多数股票会呈现出均值回归的特性，但是长期来看，很多股票价格都呈现出几何随机游走的特性。在本章，我们将会构建策略来探究“季节性”或者短期的均值回归特性。

Little profit is left using the traditional implementation of index arbitrage, we gave an example of a modified strategy.

在时间序列的均值回归中，其一般都会回归到由其历史数据决定的均值上，而在cross-sectional mean reversion 中，the cumulative return of the instruments in a basket will revert to the cumulative return of the basket。需要注意的一点是，此处提及的回测收益结果并不包含手续费，因为交易手续费根据选择的股票的不同，交易方法的不同而不同。

## The Difficulties of Trading Stock Pairs

Pair Trading 是最初的机构投资者们使用的交易算法，到现在已经被用烂无利可图了。单只股票一般都是不平稳的，即使使用数只股票来获得协整关系，你依然难以保证其样本外的稳定性。风水轮流转，股票市场上的风水转的很快，而且两家公司即使处于相同行业，其表现也一般不同。除非，你对每一只股票都深入了解，并总能在其大跌之前脱手，一般很难在同一个股票篮子使用均值回归策略获利。

除却上述基本的问题之外，还有两个技术上的难题：

1. Short-scale constraint.

short squeeze

若你的做空策略的篮子中存在难以融到的券，那即使你的策略可以赚钱，你依然可能因借不到券而在最不合适的时机和最不合适的价格被强制平仓导致巨亏。同时还要注意交易规则对卖空的限制。

2. Second difficulty arises in the intraday trading of stock pairs.

主要就是该策略被用烂了，获利空间小，日内平仓的话，基本获取不到收益。

为什么在过去pair trading就能够获利呢，主要是因为那时候市场更加的缺乏效率，而现在，满世界的代码在跑着，想用通常的算法来获利，难了。当然，这些说的都是美国市场，在中国的市场上其效果还不一定。


## Trading ETF Pairs (and Triplets)

开放型指数基金

和股票组合不同的是，ETF组合之间一旦出现协整关系，就会比较稳定。这是因为一揽子股票组合其对应的经济基础相比于单只股票的基本面更加稳定。

Another  favorite ETF pairing of mine is between a commodity ETF and an ETF of companies that produce that commodity. For example gold fund GLD versus the gold miners fund GDX. 其逻辑在于，金矿公司的产品是黄金，其公司市值必然和黄金现价存在协整关系。

然而奇怪的是，其协整关系仅仅维持在July 14， 2008，之后，其协整关系就丢失了。这一天发生了什么，在这一天，原油价格达到145美元每桶，到达了一个顶峰，导致金矿公司的成本剧增，其利润下降，公司股价下跌，和黄金价格的协整关系丢失。

若我们将原油基金USO也加入到我们的篮里，将其和GLD、GDX一起研究，就会发现，July 14， 2008之后直到2012年，三者均存在协整关系。

People will think the oil fund USO versus the energy sector fund XLE is another example of a commodity versus commodity producer pair but actually, it is different from the Gold.


## Intraday Mean Reversion: Buy-on-Gap model

我们的目标是找到日内平仓交易的均值回归特性。

The rule of the strategy are:

1. Select all stocks near the market open whose reurns from their previous day's lows to today's opens are lower than one standard deviation. The standard deviation is computed using the daily close-to-close returns of the last 90 days. These are the stocks that **gappedn down**.

2. Narrow down this lsit of stocks by requiring their open prices to be higher than the 20-day moving average of the closing prices.

3. Buy the 10 stocks within this list that have the lowest returns from their previous day's lows. If the list has fewer than 10 stocks, then buy the entire list.

4. Liquidate all positions at the market close. 


其内在逻辑在于某天stock index futures are down before the open, 某些股票由于恐慌性的抛售会被低估，但当恐慌情绪结束的时候，股价会慢慢回升。

规则2这么写是因为，那些跌得太多的股票往往是因为基本面恶化，其有很大的概率涨不回来。


**Example 4.1: Buy-on-Gap Mode on SPX stocks**

$op$ : daily open price ($T \times N$);

$lo$ : daily lows ($T \times N$);

$cl$ : daily closes ($T \times N$);

$N$ :  number of stocks in the  universe;

$T$ : number of days.

该部分的代码保存在`bog.m`中

```{matlab}
topN = 10; % max number of positions
entryZscore = 1;
lookback = 20;  % for moving average

stdretC2C90d = backshift(1, smartMovingStd(calulateReturns(cl, 1), 90));
buyPrice = backshift(1, lo).*(1-entryZscore*stdretC2C90d);

retGap = op-backshift(1, lo) ./ backshift(1, lo);
pn1 = zeros(length(tday), 1);
positionTable=zeros(size(cl));

ma = backshift(1, smartMovingAvg(cl, lookback));

for t=2:size(cl, 1)
  hasData = find(isfinite(retGap(t, :)) & op(t, :) < buyPrice(t, :) & op(t,:) > ma(t,:));

  [foo idxSort] = sort(retGap(t, hasData), 'ascend');
  positionTable(t, hasData(idxSort(1:min(topN, length(idxSort)))))=1;
end

ret02C = (cl-op)./op;
pn1 = smartsum(positionTable.*(retO2C), 2);
ret = pn1/topN;
ret(isnan(ret)) = 0;
```

使用2006.5.11到2012.5.24的数据进行回测，该策略可实现8.7%的APR， 夏普比率1.5。其cumulative returns curve 见Figure 4.1。

![FIGURE 4.1 Cumulative Returns of Buy-on-Gap Model](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-4-1.png)

同样的，我们可以使用同样的原理来进行做空，

![FIGURE 4.2  Cumulative Returns of Short-on-Gap Model](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-4-2.png)

该策略有多种变种，比如，可以同时进行多空操作，可以进行对冲操作，也可以同时在多个板块进行操作。总之，一句话，没有协整关系的价格序列可能在某特定时间段展现出周期性或阶段性的协整关系。

## Arbitrage between an ETF and Its Component Stocks

ETF和其构成股票之间的套利。

If the stocks are weighted in the same way used to construct the index, then the market value of the portfolio will cointegrate very tightly with the index futures.然而还是老问题，该策略太老套了，现在恐怕已经少有套利空间了。

在我们的例子中，我们选取20070101到20071231一年时间，第一步，使用Johansen检验（显著性90%），找到所有和SPY存在协整关系的股票；第二部，给予所有股票相同的权重配置成一个资产篮子；第三步，对该资产篮子和SPY再次进行Johansen检验（虽然每只股票均和SPY协整，但是整个篮子却未必）。We are using the log price on the second test, because we expect to rebalance the portfolio every day so that the capital on each sotck is constant. 若在第二次检验中确认了协整关系，那么我们结下来就对资产篮子实施线性均值回归策略。

**Example 4.2: Arbitrage between SPY and Its Compontent Stocks**

该部分的代码保存在`indexArb.m`中。stocks和etf部分的数据保存在两个struct中，其内容和上例中的参数相同。

```{matlab}
trainDataIdx = find(tday >= 20070101 & tday <= 20071231);
testDataidx = find(tday > 20071231)

isCoint = false(size(stks.stocks));
for s=1:length(stks.stocks)
  % combine the two time series into a matrix y2 for
  % input into Johansen test
  y2 = [stks.cl(trainDataIdx, s), etf.cl(trainDataIdx)];
  badData = any(isnan(y2), 2);
  y2(badData, :) = [];  % remove missing data
  
  if (size(y2, 1) > 250)
    results = johansen(y2, 0, 1);  % johansen test
      % with non-zero offset but zero drift, and the lag k=1
    if (results.lr1(1) > results.cvt(1, 1))
      isCoint(s) = true;
    end
  end
end 

length(find(isCoint))

% 该例子中找到了98只股票和SPY协整
% 接下来进行上述第二次协整检验
```


```{matlab}
yN = stks.cl(trainDataIdx, isCoint);
logMktVal_long = sum(log(yN), 2);  % the net market value of the long-only portfolio is 
    % the same as the "spread"

% test if the protfolio cointegrates with SPY
ytest = [logMktVal_long, log(etf.cl(trainDataIdx))];
results = =johansen(ytest, 0, 1);  % johansen test with non-zero
    % offset but zero drift, and with the lag k=1.
prt(results);
```

![第二次协整检验结果](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-4.1.png)

例子中检验结果显示，资产组合和SPY在95%的显著性水平上存在协整关系。Next, we use the Johansen eigenvector to determine the weights of SPY versus that of the stock portfolio.

There are infact two cointegrating relations, but we will pick the one with the **largest eigenvalue**——the first columns of the eigenmatrix——to form this stationary portfolio.

因为我们使用的是价格的log值，那么，这里的对冲比率代表的就是dollar capital allocation, not number of shares.

接下来对该组合使用线性均值回归策略。

```{matlab}
yNplus  = [stks.cl(testDataidx, isCoint), etf.cl(testDataidx)];
% array of stock and ETF price
weights = [repmat(results.evec(1, 1), size(stks.cl(testDataidx, isCoint))), 
           repmat(results.evec(2, 1), size(etf.cl(testDataidx)))];
          % capital allocation among the stocks and SPY.

logMktVal = smartsum(weights.*log(yNplus), 2);
% log market value of log-short portfolio
lookback = 5;
numUnits=-(logMktVal-movingAvg(logMktVal, lookback))./movingStd(logMktVal, lookback);
positions = repmat(numUnits, [1, size(weights, 2)]).*weights;
pn1 = smartsum(lag(positions, 1).*(log(yNplus)-lag(log(yNplus), 1)), 2);
ret=pn1./smartsum(abs(lag(position, 1)), 2);
ret(isnan(ret)) = 0;

```

该策略的ARP是4.5%，夏普比率1.3。见Figure 4.3。收益并不高，the reason lies in the fact that, we have not retrained the model perioodically to select new constituent stocks with new hedge ratios.

![Culmulative Returns of Arbitrage betweenn SPY and its Component Stocks](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-4-3.png)


## Cross-Sectional Mean Reversion: A Linear Long-Short Model

For many portfolio stock-trading strategies, the eduge comes precisely from the indelligent daily selection or reweghting of stocks.

一般来说，所谓的"Cross-sectional" 均值回归策略多用于股票而不是期货或者货币市场，在该策略中，股票价格并不一定真的要回归到其历史价格水平上来。Rather, the fous is on their short-term relative returns, and we rely on  the serial anti-correlation of these relative returns to generate profits.In most cases, the relative returns are compted as a stock's return minus the average returns of all the stocks in a particular universe.So we expect the underperformance of a stock to be followed by overperformance, and vice versa.

We invest in every stock from some favoriate index such as  S and P 500, S and P 1500, or Russell 2000, but with different capital allocation per stock ($w_i$).

$$
w_i = -(r_i - <r_j>) / \sum_k |r_k - <r_j>|  \qquad (4.1)
$$

$_i$ : the daily return of the $i^{th}$ stock;

$<r_j>$: the average daily return of all the stocks in the index;

**Example 4.3: Linear Long-Short Model on stocks**

源码在`andrewlo_2007_2013.m`中

```{matlab}
ret=(cl-lag(cl, 1)) ./ lag(cl, 1);  % daily returns

marketRet = smartmean(ret, 2);  % equal weighted market index return

weights = -(ret-repmat(marketRet, [1 size(ret, 2)]));
weights = weights ./ repmat(smartsum(abs(weights), 2) [1 size(weights, 2)]);
dailyret=smartsmu(backshift(1, weights) .* ret, 2);  % capital is always one
```

该策略可实现13.7%的APR，夏普比率1.3。


![Figure 4.4 Cumulative Returns of linear Long-Short Model](https://cdn.jsdelivr.net/gh/shiwz11/pics_public@master/FMDPics/ATWSR-4-4.png)


看似该模型收益不高，但是其贵在“线性”，无参。更可贵的是，在雷曼兄弟倒闭的2008年，该策略的APR为30%，在充满了对美国联邦债务的焦虑以及希腊债务危机影响的2011年，其实现了11%的APR。

一个增强其收益的方法： using the return from the previous close to today's open to determine the weights for entry at the open.然后，进行日内平仓，该策略也就变成了一个日内交易策略。

**Example 4.4: Intraday Linear Long-Short Mode on Stocks**

```{matlab}
ret = (op-backshift(1, cl))./backshift(1, cl);  % daily returns
marketRet = smartmean(ret, 2); % equal weighted market index returns
weights = -(ret-repmat(marketRet, [1 size(ret, 2)]));
weights = weights .repmat(smartsum(abs(weights), 2), [1 size(weights, 2)]);
dailyret = smartsum(weights .* (cl-op)./op, 2) ./ smartsum(abs(weights), 2);
```

增加了该buff之后，同时期的APR就变成了73%，夏普比率4.7。但是这也导致了另外的弊端：

1. 交易费用加倍，因为现在我们一天要交易两次。

2. Since this strategy have to use the "open" prices to determine the trading signals for entry at the open, it is subject to the same trading signal noise that mentioned in the Buy-on-Gap Model in example 4.1.

上面两个例子中我们用到的指标是"relative-returns"， 但是我们有更好的指标，比如，广受欢迎的P/E指标(price-earnings ratio 市盈率).


## 总结

- Are you tempted to trade pairs of stocks because of the enormous number of choices? Beware of changes in companies' fundamentals that can render out-of sample performance quite poor despite stellar backtest results.

- Trading a portfolio of cointegrating ETFs can be better than pair-trading stocks.

- Are you pair trading ETFs that hold futures? Beware of the role of roll returns (展期收益) in determining total reutrns of futures.

- Seasonal of intraday mean reversion is hard to detet with usual stationarity or cointegration tests, but can be **very profitable**.

- Imposing momentum filter on mean-reversal strategies typically improves their consistency.

- Do you think that index arbitrage between stocks and futures is no longer profitable? Try a subset of the stocks in the index.

- Cross-sectional mean reversion strategies can be implemented very easily with a linear long-short strategy.

- The variable used fo ranking stocks in a cross-sectional mean reversion strategy is typically relative return, but it can be other fundamental factors such as P/E ratio.

# Mean Reversion of Currencies and Futures

Currencies and futures are the domain of momentum traders.Opportunities for mean reversion strategies in currencies and futures are **limited, but not nonexistent**.

## Trading Currency Cross-Rates

The basic idea in forming a stationary portfolio of foreign currencies is that we need to find countries that have similar economic fundamentals.

Trading currency pairs has a number of advantages compared to trading their corresponding stock index ETF pairs.1.货币市场流动性更高，这也意味着更低的交易费用；2.货币市场可用的杠杆更高，且货币市场没有做空限制（真的假的？）；3.货币市场可全天候交易，这意味着我们有更多的机会。

货币市场的交易机制和基金市场相当不同。先介绍一些术语。If we are trading the cross-rate AUD.ZAR, AUD is called the base currency (基准货币), ZAR is called the quote currency (计价货币)。

In Example 5.1, we focus on trading two currencies that can ultimately be reduced to a pair with a common quote currency $USD: B_1. USD - B_2. USD$.So the reuturns of a portfolio with $n_1$  units of $B_1. USD$ and $n_2$ units of $B_2.USD$ is:

$$
r(t+1) = \frac{n_1 y_{1,U}(t) r_1(t+1) + n_2 y_{2,U}(t)r_2 (t+1)}{|n_1|y_{1,U}(t)+ |n_2 y_{2,U}(t)|} \qquad (5.1)
$$

$r_i$ : the return of $B_i. USD$:

$$
r_i(t+1) = (y_{i,U}(t+1)-y_{i,U}(t))/y_{i,U}(t) \qquad (5.2)
$$

$y_{i,U}(t)$ : the quotes for $B_{i}.USD$ at t.


If a portfolio has $n_{1}^{\prime}$ units of $USD. Q_1$ and $n_{2}^{\prime}$ units of $USD.Q_2$ instead, then the return can be written more simply as:

$$
r(t+1) = \frac{n_{1}^{\prime} r_1 (t+1) + n_{2}^{\prime} r_2 (t+1)}{|n_{1}^{\prime}|+|n_{2}^{\prime}|} \qquad (5.3)
$$

$$
r_i(t+1) = (y_{U,i}(t+1) - y_{U,i}(t)) / y_{U,i}(t) \qquad (5.4)
$$

$y_{U,i}(t)$ : quotes for $USD.Q_i$ at t.

式子 5.2 和5.4没有考虑展期利息。

**Example 5.1:Pair Trading USD.AUD versus USD.CAD Using the Johansen Eigenvector**

The example here is quite similar to the one in Example 3.1, but here we use a fixed training set of 250 days to compute the hedge ratio, but still we will use a look-back of 20 days to compute the moving average and the standard deviation.

$usdcad, usdaud$: $T\times 1$ array;

$yport$: $T \times 1$the market value of a unit portfolio;

$positions$: $T \times 1$, the market values in USD of AUD.USD and CAD.USD that we should own.

The source code is in `AUDCAD_unequal.m`

```{matlab}
cad = ./ usdcad.cl;
aud = audusd.cl;

y = [aud cad];
trainlen = 250;
lookback = 20;
hedgeRatio = NaN(size(y));
numUnits = NaN(size(y, 1), 1);
for t=trainlen+1:size(y, 1)
  res=johansen(log(y(t-trainlen:t-1, :)), 0, 1);
  hedgeRatio(t, :) = res.evec(:, 1)';
  yport = sum(y(t-lookback+1:t, :).* repmat(hedgeRatio(t, :), [lookback 1]), 2);
  ma = mean(yport);
  mstd = std(yport);
  zScore=(yport(end)-ma) / mstd;
  numUnits(t)=-(yport(end)-ma)/mstd;
end

positions = repmat(numUnits, [1 size(y, 2)]).*hedgeRatio .* y;
pnl = sum(lag(positions, 1).*(y-lag(y, 1))./lag(y, 1), 2);
ret = pnl./sum(abs(lag(positions, 1)), 2);
```


![Cumulative Returns of USD.AUD versus USD.CAD Strategy](figs/ATWSR-5-1.png)

The daily return of tow pairs of entirely different cross-rates portfolio $B_1 .Q_1$ versus $B_2. Q_2$ is given in equation 5.1:

$$
r_i(t+1) = \{log(y_{i, Q_i}(t+1)) - log(y_{i, Q_i}(t)) \}
$$

$y_{i, Q_i}(t)$ : quote for $B_i . Q_i$;

## Rollover Interests in Currency Trading

A feature of trading currency cross-rate is the differential interest rate earned or paid if the cross-rate position is held overnight.

If we are long a pair B.Q overnight, the interest differential is $i_B-i_Q$, where $i_B$ and $i_Q$ are the daily interest rates of currency B and Q, respectively.

When we calculate the Sharpe ratio for any strategy, we need to calculate the excess return, cause the  Sharp ratio is the ratio of the average excess return devided by the standard deviation of the excess returns, suitably annualized.The excess return is the return of the positions that the strategy holds minus the financing cost of those positions. So if we only have intraday positions, the financing cost is zero.

The excess return $r_{t+1}$ from holding a cross-rate position $POS_{B.Q}$ from day t to day $t+1$ is

$$
r(t+1) = \{log(y_{B.Q}(t+1)) - log(y_{B.Q}(t)) +log(1+i_B(t)) - log(1+i_Q(t)) \} \quad (5.6)
$$

$y(t)$ : quote for BQ at t.

**Example 5.2:Pair Trading AUD.CAD with Rollover Interests**

$dailyCl$: $T\times 1$, daily closing prices of AUD.CAD;

$tday$: $T\times 1$, corresponding trading dates.

The source code can be downloaded as `AUDCAD_daily.m`

```{matlab}
lookback=20;
# Triple rollover interest on Wednesday for AUD
isWednesday = weekday(datenum(num2str(tday), 'yyyymmdd')) == 4;
aud_dailyRates(isWednesday)=3*aud_dailyRates(isWednesday);

cad_dailyRates = zeros(size(tday));
# Triple rollover interest on Thursday for CAD
isThursday = weekday(datenum(num2str(tday), 'yyyymmdd')) == 5;
cad_dailyRates(isThursday)=3*cad_dailyRates(isThursday);

ma=movingAvg(dailyCl, lookback);;
z=(dailyCl - ma);

ret = lag(-sign(z), 1).*(log(dailyCl) - 
                           lag(log(dailyCl) + log(1+aud_dailyRates) - 
                                 log(1+cad_dailyRates), 1));
```

![](https://v2fy.com/asset/0i/ChineseBQB/035TomAndJerry_%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0BQB/%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A000010-%E7%94%9F%E6%97%A0%E5%8F%AF%E6%81%8B.jpg)


## Trading Futures Calendar Spread

### 展期收益，现货升水和期货升水

If the contract are in backwardation, meaning the enar contracts have higher prices than the far contracts, then the roll returns will be positive.

$$
F(t,T) = S(t) exp(\gamma (t-T)) \quad (5.7)
$$

$t$: The current time;

$T$: The expiration time;

$S(t)$: The spot price;

$\gamma$:roll reutrn;

$\alpha$: spot return.


$$
S(t) = c e^{\alpha t} \quad (5.8)
$$

$$
F(t, T) = ce^{\alpha t} exp(\gamma(t - T)) \quad (5.9)
$$

$$
\partial (logF(t, T)) / \partial = \alpha + \gamma \quad (5.10)
$$

$$
-\partial (log(F(t, T))) / \partial T = \gamma \quad (5.11)
$$

Cause of the presence of roll return, the ETF of commodity prodocers may not cointegrates with the spot price of the price of that commodity, be ware of that.

**Example 5.3: Estimating Spot and Roll Returns Using the Constant Reutrns Model**

Program can be downloaded as `estimateFUturesReturns.m`

$\tau$ : number of trading days;

$M$ : number of trading days;

First find the average annualized spot return with a simple regression below:

```{matlab}
T = [1:length(spot)]';
T(isBadData) = [];
res = ols(log(spot), [T ones(size(T, 1), 1)]);

fprintf(1, `Average annualized spot return=%f\n`, 252*smartmean(res.beta(1)))
```

Next, fit the forward curve (the future price as a function of maturity date) in order ot obtain the values for the roll return $\gamma$. 

```{matlab}
# The value of gamma is stored in a tau x 1a array gamma

gamma = NaN(size(tday));
for t=1:length(tday)
  FT=cl(t, :)';
  idx=find(isfinite(FT));
  idxDiff=fwdshift(1, idx)-idx; % ensure consecutive month futures
  if (length(idx) >= 5 && all(idxDiff(1:4) == 1))
    FT=FT(idx(1:5));
    T=[1:length(FT)]';

    res=ols(log(FT), [T ones(size(T, 1), 1)]);
    gamma(t) = -12*res.beta(1);
  end
end
```