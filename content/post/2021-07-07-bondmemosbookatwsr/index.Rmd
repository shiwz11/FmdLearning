---
title: BondMemosBookATWSR
author: Shiwz11
date: '2021-07-07'
slug: bondmemosbookatwsr
categories:
  - Memos
tags:
  - Bonds
---

# 写在前面

该笔记来自于：
Algorithmic Trading Winning Strategies and Their Rationale

by:Ernest P. Chan


# Backtesting and Automated Execution

回测和自动化执行

市面上大部分公开的策略都不会对策略的细节进行详细说明，而这些细节会对策略的盈利能力造成巨大影响，因此，回测策略并找出最优参数就成为了必要。而且，回测有助于发现策略中隐藏的缺陷。

## 回测中常见的错误

### 前视性偏误

Look-ahead bias : 顾名思义，说的是，你的回测程序使用了未来的（明天的）交易价格来决定当前的（今天的）交易价格。一种常见的前视性偏误是在回测中，使用某日的价格高点或低点来决定策略的进入信号。实际上，在该交易日完结之前，我们无法知道该交易日的实际价格高点和低点。这种偏误属于简单的变成上的失误。

### 数据透视偏差和线性模型的妙处

类似于数据过拟合，当你使用了过多的的参数来拟合某段时间特定的市场模式时，虽然拟合效果可能会很好，但是，这种特殊的市场模式在未来很可能不会再出现，就造成了其样本外预测效力极差。这称之为数据透视偏差。

诊断这种偏误的方法也很简单，就是使用样本外数据对模型的预测效果进行评价，但时不幸的是，当模型样本外预测能力表现较差的时候，你真的有决心舍弃之前所有的工作，重新拟合模型吗。恐怕不是，我们可能会针对模型做出这样或那样的改变来使其样本外预测能力和样本内预测能力都说的过去，而实际来看，当你这么做的时候，你实际上是把样本外数据当作样本外数据来用了，这就违反了科学性。

更好的办法是，**交叉验证**。一般来说，非线性模型相比于线性模型会有更多的参数，也有更大的可能引致过拟合。为了避免这种错误，我们通常选择遵循奥卡姆剃刀原则，选择尽可能少的参数。

另一个重要的问题是对分布的假设，我们根据经验知道，正太分布通常并不能很好的描述实际金融数据，但是根据奥卡姆剃刀原则，除非你有强有力的证据表明，应当使用其他分布，那么，你就应该使用最简单的正态分布。

线性模型好就好在它简单，简单并不意味着无效。线性模型生效大多数时候是因为其抓住了市场失灵这一事实。

Daniel Kahneman , the Nobel Prize-winning economist, wrote in hist bestseller *Thinking, Fast and Slow* that "formulas that assign equal weights to all the predictors are often superior, because thay are not affected by accidents of sampling"(Kahneman, 2011)

a simple way to rank a stock:

$$
rank_s = \sum_{i}^{n} sign(i) rank_{s}(i)
$$

### 股票分割和股息调整

股票的分割虽然不会使得受伤的股票的总市值发生变化，但就一份股票来看，会造成价格的骤然下跌。如果不对这种情况进行调整，会造成交易程序产生错误的交易信号。

### 股票数据中的幸存者偏差

如果你的数据库中不包含已经退市的股票，那么就会有极大的可能性被幸存者偏差所蒙蔽。因为你的数据库中的数据都是存活至今的股票，而如果你的交易策略是购买前一日跌幅最大的那只股票，那么，你很有可能会血本无归，因为，该公司情况可能继续恶化，乃至退市。

### 一级与综合股价

一级(primary)股价和综合(Consolidated)股价的问题来源于不同的公司在不同的交易所市场上市。如果使用综合股价来回测模型的话，有极高的概率会夸大策略的收益率。因此，最好的方案是我们有权限连接到实时的Primary Data，但是如果我们实在没有这种权限的话，那就只能自求多福，对回测结果保持谨慎怀疑了。

### 货币交易报价的场所依赖

相比于股票市场，货币市场的交易更加的碎片化（割裂化）。交易员并不会拿当前交易在所有市场上进行综合比价。因此，我们必须使用同一市场的历史数据进行回测并在同一市场应用我们的策略。

还是数据的问题，一般来说，特定交易市场的数据需要特定的权限获得，即使可获得，其数据滞后性问题也必须被考虑在内。因此，找个合适的平台供应商很重要。

### 卖空的限制

理论上可以对市场上任何一只股票进行卖空，但是现实往往存在限制，比如，针对某只股票存在大量卖空，那么你的卖空操作就必须支付相应的费用，这增加了成本，或者更极端的说，甚至可能借不到用以卖空的券。另一种情况是政策限制对某种券的卖空，比如，2008雷曼兄弟破产之后，美国SEC在几个月内禁止了对金融行业股票的卖空操作。

我们的策略必须考虑以上情形，否则，虽然可以得到美好的纸面收益率，但却是镜花水月，不可实现。

另一个对卖空的限制是所谓的“报升规则”(Uptick Rule)，指的是，卖空交易不能以低于当时最佳卖盘价格(即，卖盘中最低价格)进行，该规则限制了在价格下跌时对价格的打压。另外还需注意熔断机制等补充规则的影响。

### 期货连续合约

创建一个连续合约的第一步是在给定数个展期日的情况下，先将近月交割合约的价格组合起来。但这种情况下，在展期日前一天和展期日当天就会出现一个明显的价格gap，而这会造成回测中收益的错误。

### 期货收盘价和结算价

一般来说，供应商提供的期货收盘价实际上是结算价，而不是当天最后一笔期货交易的成交价。一般来说，结算价和当前最后一笔交易的成交价并不一样。需要注意的是，有些数据供应商会提供逐笔交易的数据，这种数据是真实的交易价格。在这种情况下，收盘价将会是最后一笔交易的价格。

大多数情况下，我们应当使用结算价，因为，如果你在临近收市的时候交易的话，改价格最为接近你的成交价格。后面的不太明白了


如果你构建一个日间利差交易策略或者使用日间期货价格来回测你的利差策略，那么，你将会用到买卖双方的bid和ask价格；当利差为负的时候，你将会需要该利差数据的日间原始数据。

不同券最后一笔的利差策略需要注意一点就是，他们的最后一笔交易发生时间往往是不同步的，如果相差较多，可能对利率收益的实现产生影响。

市场间利差策略的一个需要注意的点是，如果合约是在不同的交易所交易的，那么，他们可能会有不同的收市时间，因此使用其收盘价来做利差策略是不可行的。总之，要注意其交易时间的同步性。

### 回测的统计显著性：假设检验

回测中的统计检验遵循以下步骤：

1. 基于有限样本，我们首先计算出待检验指标，比如某策略的日平均收益；

2. 原假设：基于无限样本的真实日平均收益为0；

3. 假设日收益的分布已知，并且又零均值；

4. 然后根据假设的概率分布计算出p值，来决定是否拒绝原假设，并确定其显著性水平。

其中，比较麻烦的是第三步，怎么确定其概率分布。一个简单的做法是，假设其为高斯分布，然后，根据样本的标准差估算其分布标准差，一般来说，有高夏普比率更容易得到统计显著的结果。另一种方法是使用蒙特卡洛模拟出历史价格数据，并将模拟结果代回我们的策略来推断出收益的概率分布。

第三种方法由Andrew Lo and his collaborators (Lo, Mamaysky, and Wang, 2000)提出，在该方法中，不模拟价格数据，而是根据真实交易数据产生出模拟的交易数据。很显然的一点是，三种方法得出的概率分布进行的假设检验很可能会得出不同的结果。

**Example 1.1**：

该例子针对第六章的动量策略实施了上述三种假设检验。若策略产生12个月的正收益，则购买期货并持有一个月。

- 第一种检验方法

该方法很简单，假设数据服从零均值的高斯分布，标准差来自于样本数据。假设`ret`是一个$T\times 1$的array。使用matlab计算其统计量如下：

```{matlab}
# matlab and R
mean(ret) / std(ret)*sqrt(length(ret))
```

- 第二种检验方法

该方法针对期货合约产生出一系列模拟的每日汇报数据（请注意，不是模拟策略的收益率）。模拟出的数据相比于真实数据会有相同的均值、标准差、峰度和偏度。如果我们测试发现我们的策略在模拟的数据中相比于真实数据中，能产生一样好甚至更好的收益，那么**很不幸**，这说明，我们的策略没有抓住真实数据的任何趋势和序列相关性。而其之所以能盈利仅仅是因为运气。

使用matlab来模拟出之前所述的数据，然后，我们使用模拟出的收益数据模拟出价格数据，最后，我么在模拟出的数据上跑10000次我们的策略，并观察其收益率。统计出有多少次，其收益率大于等于真实数据上的收益率。

```{matlab}
# matlab
clear;

% load('../Data/inputDataOHLCDaily_20120511', 'syms', 'tday', 'cl');
load('inputDataOHLCDaily_20120511', 'syms', 'tday', 'cl');
idx=strmatch('TU', syms, 'exact');

tday=tday(:, idx);
cl=cl(:, idx);

lookback=250;
holddays=25;

longs=cl > backshift(lookback, cl)  ;
shorts=cl < backshift(lookback, cl) ;

pos=zeros(length(cl), 1);

for h=0:holddays-1
    long_lag=backshift(h, longs);
    long_lag(isnan(long_lag))=false;
    long_lag=logical(long_lag);
    
    short_lag=backshift(h, shorts);
    short_lag(isnan(short_lag))=false;
    short_lag=logical(short_lag);
    
    pos(long_lag)=pos(long_lag)+1;
    pos(short_lag)=pos(short_lag)-1;
end

marketRet=(cl-backshift(1, cl))./backshift(1, cl);
marketRet(~isfinite(marketRet))=0;

ret=backshift(1, pos).*marketRet/holddays;

ret(isnan(ret))=0;

% Gaussian hypothesis test
fprintf(1, 'Gaussian Test statistic=%4.2f\n', mean(ret)/std(ret)*sqrt(length(ret)));
% Gaussian Test statistic=2.93

% Randomized market returns hypothesis test
moments={mean(marketRet), std(marketRet), skewness(marketRet), kurtosis(marketRet)};
numSampleAvgretBetterOrEqualObserved=0;
for sample=1:10000
    marketRet_sim=pearsrnd(moments{:}, length(marketRet), 1);
    cl_sim=cumprod(1+marketRet_sim)-1;
    
    longs_sim=cl_sim > backshift(lookback, cl_sim)  ;
    shorts_sim=cl_sim < backshift(lookback, cl_sim) ;
    
    pos_sim=zeros(length(cl_sim), 1);
    
    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag);
        
        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos_sim(long_sim_lag)=pos_sim(long_sim_lag)+1;
        pos_sim(short_sim_lag)=pos_sim(short_sim_lag)-1;
    end

    
    ret_sim=backshift(1, pos_sim).*marketRet_sim/holddays;
    ret_sim(~isfinite(ret_sim))=0;
    
    if (mean(ret_sim)>= mean(ret))
        numSampleAvgretBetterOrEqualObserved=numSampleAvgretBetterOrEqualObserved+1;
    end
end

fprintf(1, 'Randomized prices: p-value=%f\n', numSampleAvgretBetterOrEqualObserved/10000);
% p-value=0.027500


% Randomized entry trades hypothesis test

numSampleAvgretBetterOrEqualObserved=0;
for sample=1:100000
    P=randperm(length(longs));
    longs_sim=longs(P);
    shorts_sim=shorts(P);
    
    pos_sim=zeros(length(cl), 1);

    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag);
        
        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos(long_sim_lag)=pos(long_sim_lag)+1;
        pos(short_sim_lag)=pos(short_sim_lag)-1;
    end

    ret_sim=backshift(1, pos_sim).*marketRet/holddays;

    ret_sim(isnan(ret_sim))=0;
    
  
    if (mean(ret_sim)>= mean(ret))
        numSampleAvgretBetterOrEqualObserved=numSampleAvgretBetterOrEqualObserved+1;
    end

end
fprintf(1, 'Randomized trades: p-value=%f\n', numSampleAvgretBetterOrEqualObserved/100000);
```


书中的结果显示，在10000次模拟中，有1166次的平均策略收益大于实际观测的平均收益。这也就意味着我们只能以88%的概率拒绝原假设。

- 第三种检验方法

matlab程序如下：

```{matlab}
numSampleAvgretBetterOrEqualObserved=0;

for sample=1:100000
    P = randperm(length(longs));
    longs_sim=longs(P);
    shorts_sim=shorts(P);

    pos_sim=zers(length(c1), 1);

    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag)；

        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos(long_sim_lag)=pos(long_sim_lag)+1;
        pos(short_sim_lag)=pos(short_sim_lag)-1;
    end

    ret_sim=backshift(1, pos_sim).*marketRet/holiddays;

    ret_sim(isnan(ret_sim))=0;

    if (mean(ret_sim) >= mean(ret))
    numSampleAvgretBetterOrEqualObserved=...
      numSampleAvgretBetterOrEqualObserved+1;
    end

end

```


