---
title: BondMemosBookATWSR
author: Shiwz11
date: '2021-07-07'
slug: bondmemosbookatwsr
categories:
  - Memos
tags:
  - Bonds
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<div id="写在前面" class="section level1">
<h1>写在前面</h1>
<p>该笔记来自于：
Algorithmic Trading Winning Strategies and Their Rationale</p>
<p>by:Ernest P. Chan</p>
</div>
<div id="backtesting-and-automated-execution" class="section level1">
<h1>Backtesting and Automated Execution</h1>
<p>回测和自动化执行</p>
<p>市面上大部分公开的策略都不会对策略的细节进行详细说明，而这些细节会对策略的盈利能力造成巨大影响，因此，回测策略并找出最优参数就成为了必要。而且，回测有助于发现策略中隐藏的缺陷。</p>
<div id="回测中常见的错误" class="section level2">
<h2>回测中常见的错误</h2>
<div id="前视性偏误" class="section level3">
<h3>前视性偏误</h3>
<p>Look-ahead bias : 顾名思义，说的是，你的回测程序使用了未来的（明天的）交易价格来决定当前的（今天的）交易价格。一种常见的前视性偏误是在回测中，使用某日的价格高点或低点来决定策略的进入信号。实际上，在该交易日完结之前，我们无法知道该交易日的实际价格高点和低点。这种偏误属于简单的变成上的失误。</p>
</div>
<div id="数据透视偏差和线性模型的妙处" class="section level3">
<h3>数据透视偏差和线性模型的妙处</h3>
<p>类似于数据过拟合，当你使用了过多的的参数来拟合某段时间特定的市场模式时，虽然拟合效果可能会很好，但是，这种特殊的市场模式在未来很可能不会再出现，就造成了其样本外预测效力极差。这称之为数据透视偏差。</p>
<p>诊断这种偏误的方法也很简单，就是使用样本外数据对模型的预测效果进行评价，但时不幸的是，当模型样本外预测能力表现较差的时候，你真的有决心舍弃之前所有的工作，重新拟合模型吗。恐怕不是，我们可能会针对模型做出这样或那样的改变来使其样本外预测能力和样本内预测能力都说的过去，而实际来看，当你这么做的时候，你实际上是把样本外数据当作样本外数据来用了，这就违反了科学性。</p>
<p>更好的办法是，<strong>交叉验证</strong>。一般来说，非线性模型相比于线性模型会有更多的参数，也有更大的可能引致过拟合。为了避免这种错误，我们通常选择遵循奥卡姆剃刀原则，选择尽可能少的参数。</p>
<p>另一个重要的问题是对分布的假设，我们根据经验知道，正太分布通常并不能很好的描述实际金融数据，但是根据奥卡姆剃刀原则，除非你有强有力的证据表明，应当使用其他分布，那么，你就应该使用最简单的正态分布。</p>
<p>线性模型好就好在它简单，简单并不意味着无效。线性模型生效大多数时候是因为其抓住了市场失灵这一事实。</p>
<p>Daniel Kahneman , the Nobel Prize-winning economist, wrote in hist bestseller <em>Thinking, Fast and Slow</em> that “formulas that assign equal weights to all the predictors are often superior, because thay are not affected by accidents of sampling”(Kahneman, 2011)</p>
<p>a simple way to rank a stock:</p>
<p><span class="math display">\[
rank_s = \sum_{i}^{n} sign(i) rank_{s}(i)
\]</span></p>
</div>
<div id="股票分割和股息调整" class="section level3">
<h3>股票分割和股息调整</h3>
<p>股票的分割虽然不会使得受伤的股票的总市值发生变化，但就一份股票来看，会造成价格的骤然下跌。如果不对这种情况进行调整，会造成交易程序产生错误的交易信号。</p>
</div>
<div id="股票数据中的幸存者偏差" class="section level3">
<h3>股票数据中的幸存者偏差</h3>
<p>如果你的数据库中不包含已经退市的股票，那么就会有极大的可能性被幸存者偏差所蒙蔽。因为你的数据库中的数据都是存活至今的股票，而如果你的交易策略是购买前一日跌幅最大的那只股票，那么，你很有可能会血本无归，因为，该公司情况可能继续恶化，乃至退市。</p>
</div>
<div id="一级与综合股价" class="section level3">
<h3>一级与综合股价</h3>
<p>一级(primary)股价和综合(Consolidated)股价的问题来源于不同的公司在不同的交易所市场上市。如果使用综合股价来回测模型的话，有极高的概率会夸大策略的收益率。因此，最好的方案是我们有权限连接到实时的Primary Data，但是如果我们实在没有这种权限的话，那就只能自求多福，对回测结果保持谨慎怀疑了。</p>
</div>
<div id="货币交易报价的场所依赖" class="section level3">
<h3>货币交易报价的场所依赖</h3>
<p>相比于股票市场，货币市场的交易更加的碎片化（割裂化）。交易员并不会拿当前交易在所有市场上进行综合比价。因此，我们必须使用同一市场的历史数据进行回测并在同一市场应用我们的策略。</p>
<p>还是数据的问题，一般来说，特定交易市场的数据需要特定的权限获得，即使可获得，其数据滞后性问题也必须被考虑在内。因此，找个合适的平台供应商很重要。</p>
</div>
<div id="卖空的限制" class="section level3">
<h3>卖空的限制</h3>
<p>理论上可以对市场上任何一只股票进行卖空，但是现实往往存在限制，比如，针对某只股票存在大量卖空，那么你的卖空操作就必须支付相应的费用，这增加了成本，或者更极端的说，甚至可能借不到用以卖空的券。另一种情况是政策限制对某种券的卖空，比如，2008雷曼兄弟破产之后，美国SEC在几个月内禁止了对金融行业股票的卖空操作。</p>
<p>我们的策略必须考虑以上情形，否则，虽然可以得到美好的纸面收益率，但却是镜花水月，不可实现。</p>
<p>另一个对卖空的限制是所谓的“报升规则”(Uptick Rule)，指的是，卖空交易不能以低于当时最佳卖盘价格(即，卖盘中最低价格)进行，该规则限制了在价格下跌时对价格的打压。另外还需注意熔断机制等补充规则的影响。</p>
</div>
<div id="期货连续合约" class="section level3">
<h3>期货连续合约</h3>
<p>创建一个连续合约的第一步是在给定数个展期日的情况下，先将近月交割合约的价格组合起来。但这种情况下，在展期日前一天和展期日当天就会出现一个明显的价格gap，而这会造成回测中收益的错误。</p>
</div>
<div id="期货收盘价和结算价" class="section level3">
<h3>期货收盘价和结算价</h3>
<p>一般来说，供应商提供的期货收盘价实际上是结算价，而不是当天最后一笔期货交易的成交价。一般来说，结算价和当前最后一笔交易的成交价并不一样。需要注意的是，有些数据供应商会提供逐笔交易的数据，这种数据是真实的交易价格。在这种情况下，收盘价将会是最后一笔交易的价格。</p>
<p>大多数情况下，我们应当使用结算价，因为，如果你在临近收市的时候交易的话，改价格最为接近你的成交价格。后面的不太明白了</p>
<p>如果你构建一个日间利差交易策略或者使用日间期货价格来回测你的利差策略，那么，你将会用到买卖双方的bid和ask价格；当利差为负的时候，你将会需要该利差数据的日间原始数据。</p>
<p>不同券最后一笔的利差策略需要注意一点就是，他们的最后一笔交易发生时间往往是不同步的，如果相差较多，可能对利率收益的实现产生影响。</p>
<p>市场间利差策略的一个需要注意的点是，如果合约是在不同的交易所交易的，那么，他们可能会有不同的收市时间，因此使用其收盘价来做利差策略是不可行的。总之，要注意其交易时间的同步性。</p>
</div>
<div id="回测的统计显著性假设检验" class="section level3">
<h3>回测的统计显著性：假设检验</h3>
<p>回测中的统计检验遵循以下步骤：</p>
<ol style="list-style-type: decimal">
<li><p>基于有限样本，我们首先计算出待检验指标，比如某策略的日平均收益；</p></li>
<li><p>原假设：基于无限样本的真实日平均收益为0；</p></li>
<li><p>假设日收益的分布已知，并且又零均值；</p></li>
<li><p>然后根据假设的概率分布计算出p值，来决定是否拒绝原假设，并确定其显著性水平。</p></li>
</ol>
<p>其中，比较麻烦的是第三步，怎么确定其概率分布。一个简单的做法是，假设其为高斯分布，然后，根据样本的标准差估算其分布标准差，一般来说，有高夏普比率更容易得到统计显著的结果。另一种方法是使用蒙特卡洛模拟出历史价格数据，并将模拟结果代回我们的策略来推断出收益的概率分布。</p>
<p>第三种方法由Andrew Lo and his collaborators (Lo, Mamaysky, and Wang, 2000)提出，在该方法中，不模拟价格数据，而是根据真实交易数据产生出模拟的交易数据。很显然的一点是，三种方法得出的概率分布进行的假设检验很可能会得出不同的结果。</p>
<p><strong>Example 1.1</strong>：</p>
<p>该例子针对第六章的动量策略实施了上述三种假设检验。若策略产生12个月的正收益，则购买期货并持有一个月。</p>
<ul>
<li>第一种检验方法</li>
</ul>
<p>该方法很简单，假设数据服从零均值的高斯分布，标准差来自于样本数据。假设<code>ret</code>是一个<span class="math inline">\(T\times 1\)</span>的array。使用matlab计算其统计量如下：</p>
<pre class="matlab"><code># matlab and R
mean(ret) / std(ret)*sqrt(length(ret))</code></pre>
<ul>
<li>第二种检验方法</li>
</ul>
<p>该方法针对期货合约产生出一系列模拟的每日汇报数据（请注意，不是模拟策略的收益率）。模拟出的数据相比于真实数据会有相同的均值、标准差、峰度和偏度。如果我们测试发现我们的策略在模拟的数据中相比于真实数据中，能产生一样好甚至更好的收益，那么<strong>很不幸</strong>，这说明，我们的策略没有抓住真实数据的任何趋势和序列相关性。而其之所以能盈利仅仅是因为运气。</p>
<p>使用matlab来模拟出之前所述的数据，然后，我们使用模拟出的收益数据模拟出价格数据，最后，我么在模拟出的数据上跑10000次我们的策略，并观察其收益率。统计出有多少次，其收益率大于等于真实数据上的收益率。</p>
<pre class="matlab"><code># matlab
clear;

% load(&#39;../Data/inputDataOHLCDaily_20120511&#39;, &#39;syms&#39;, &#39;tday&#39;, &#39;cl&#39;);
load(&#39;inputDataOHLCDaily_20120511&#39;, &#39;syms&#39;, &#39;tday&#39;, &#39;cl&#39;);
idx=strmatch(&#39;TU&#39;, syms, &#39;exact&#39;);

tday=tday(:, idx);
cl=cl(:, idx);

lookback=250;
holddays=25;

longs=cl &gt; backshift(lookback, cl)  ;
shorts=cl &lt; backshift(lookback, cl) ;

pos=zeros(length(cl), 1);

for h=0:holddays-1
    long_lag=backshift(h, longs);
    long_lag(isnan(long_lag))=false;
    long_lag=logical(long_lag);
    
    short_lag=backshift(h, shorts);
    short_lag(isnan(short_lag))=false;
    short_lag=logical(short_lag);
    
    pos(long_lag)=pos(long_lag)+1;
    pos(short_lag)=pos(short_lag)-1;
end

marketRet=(cl-backshift(1, cl))./backshift(1, cl);
marketRet(~isfinite(marketRet))=0;

ret=backshift(1, pos).*marketRet/holddays;

ret(isnan(ret))=0;

% Gaussian hypothesis test
fprintf(1, &#39;Gaussian Test statistic=%4.2f\n&#39;, mean(ret)/std(ret)*sqrt(length(ret)));
% Gaussian Test statistic=2.93

% Randomized market returns hypothesis test
moments={mean(marketRet), std(marketRet), skewness(marketRet), kurtosis(marketRet)};
numSampleAvgretBetterOrEqualObserved=0;
for sample=1:10000
    marketRet_sim=pearsrnd(moments{:}, length(marketRet), 1);
    cl_sim=cumprod(1+marketRet_sim)-1;
    
    longs_sim=cl_sim &gt; backshift(lookback, cl_sim)  ;
    shorts_sim=cl_sim &lt; backshift(lookback, cl_sim) ;
    
    pos_sim=zeros(length(cl_sim), 1);
    
    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag);
        
        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos_sim(long_sim_lag)=pos_sim(long_sim_lag)+1;
        pos_sim(short_sim_lag)=pos_sim(short_sim_lag)-1;
    end

    
    ret_sim=backshift(1, pos_sim).*marketRet_sim/holddays;
    ret_sim(~isfinite(ret_sim))=0;
    
    if (mean(ret_sim)&gt;= mean(ret))
        numSampleAvgretBetterOrEqualObserved=numSampleAvgretBetterOrEqualObserved+1;
    end
end

fprintf(1, &#39;Randomized prices: p-value=%f\n&#39;, numSampleAvgretBetterOrEqualObserved/10000);
% p-value=0.027500


% Randomized entry trades hypothesis test

numSampleAvgretBetterOrEqualObserved=0;
for sample=1:100000
    P=randperm(length(longs));
    longs_sim=longs(P);
    shorts_sim=shorts(P);
    
    pos_sim=zeros(length(cl), 1);

    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag);
        
        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos(long_sim_lag)=pos(long_sim_lag)+1;
        pos(short_sim_lag)=pos(short_sim_lag)-1;
    end

    ret_sim=backshift(1, pos_sim).*marketRet/holddays;

    ret_sim(isnan(ret_sim))=0;
    
  
    if (mean(ret_sim)&gt;= mean(ret))
        numSampleAvgretBetterOrEqualObserved=numSampleAvgretBetterOrEqualObserved+1;
    end

end
fprintf(1, &#39;Randomized trades: p-value=%f\n&#39;, numSampleAvgretBetterOrEqualObserved/100000);</code></pre>
<p>书中的结果显示，在10000次模拟中，有1166次的平均策略收益大于实际观测的平均收益。这也就意味着我们只能以88%的概率拒绝原假设。</p>
<ul>
<li>第三种检验方法</li>
</ul>
<p>matlab程序如下：</p>
<pre class="matlab"><code>numSampleAvgretBetterOrEqualObserved=0;

for sample=1:100000
    P = randperm(length(longs));
    longs_sim=longs(P);
    shorts_sim=shorts(P);

    pos_sim=zers(length(c1), 1);

    for h=0:holddays-1
        long_sim_lag=backshift(h, longs_sim);
        long_sim_lag(isnan(long_sim_lag))=false;
        long_sim_lag=logical(long_sim_lag)；

        short_sim_lag=backshift(h, shorts_sim);
        short_sim_lag(isnan(short_sim_lag))=false;
        short_sim_lag=logical(short_sim_lag);
        
        pos(long_sim_lag)=pos(long_sim_lag)+1;
        pos(short_sim_lag)=pos(short_sim_lag)-1;
    end

    ret_sim=backshift(1, pos_sim).*marketRet/holiddays;

    ret_sim(isnan(ret_sim))=0;

    if (mean(ret_sim) &gt;= mean(ret))
    numSampleAvgretBetterOrEqualObserved=...
      numSampleAvgretBetterOrEqualObserved+1;
    end

end
</code></pre>
</div>
</div>
<div id="什么时候不用进行回测" class="section level2">
<h2>什么时候不用进行回测</h2>
<p>在前面的文章中作者极力推荐对策略进行回测，而事实是，有些策略实在是太垃圾，因此，没必要浪费时间对其进行回测。</p>
<ul>
<li>Example 1:一个策略，有30%的年化收益率，0.3的夏普比率，两年的最大回撤持续期。</li>
</ul>
<p>较低的夏普比率伴随着较长的回撤持续期意味着你的策略很不稳定。其产生较高的收益很可能是因为巧合，在世纪的交易中不可复现。另一种可能是，高的收益来源于数据的过拟合，过高的回撤持续期八成会导致该策略通不过交叉验证。</p>
<p>因此，记住，对于以下两种策略不要考虑：1.收益率过高而夏普比率很低；2.策略最大回撤持续期比你能承受的最长期限还长。</p>
<ul>
<li>Example 2:一个在2007年的原油期货多头策略，回报率20%，夏普比率1.5。</li>
</ul>
<p>该策略的实际表现还不如最简单那的购买并持有策略，因此，我们一定要选择一个合适的Benchamrk.</p>
<ul>
<li>Example 3: 低买高卖策略，在年初买进10只被低估的股票，并持有一年，回测中，其在2001年的收益率388%。</li>
</ul>
<p>当我们审视该回测结果的时候，我们应该考虑以下问题：该回测结果是否使用了存在幸存者偏差的数据库，也就是说，我们使用的数据库是否包含了退市的股票；如果包含了该数据，那么该策略最有可能的收益是-100%。</p>
<ul>
<li>Example 4: 一个神经网络交易策略，有100个节点，回测中的夏普比率为6。</li>
</ul>
<p>即使对神经网络不甚了解，有一点是明确的，节点的数目和模型的参数数量是正相关的，100个节点必然会导致模型的过拟合。该模型对样本外数据会毫无预测能力。</p>
<ul>
<li>Example 5: 一个高频的E-mini SP500期货交易策略，回测中有200%的收益，夏普比率为6，每手的平均持有期限是50秒。</li>
</ul>
<p>高频交易策略的表现取决于交易中使用的订单类型。更进一步的说，高频策略的表现取决于市场的微观结构，即使我们有整个市场的交易数据，策略的实际表现依然受其他市场参与者的巨大影响。</p>
<p>更重要的是，在实际的交易中，你的高频策略八成会改变其他市场参与者的行为（海森堡不确定原理），因此，对高频策略的回测要尤其谨慎。</p>
<p>人生苦短，没必要浪费时间在垃圾策略上。</p>
</div>
<div id="回测是否对未来收益具有预测力" class="section level2">
<h2>回测是否对未来收益具有预测力</h2>
<p>即使我们的策略在回测中表现除了较高的统计显著性，其对未来的预测能力建立在以下假设上：在未来，价格的时间序列的性质不发生变化。而实际上，该假设往往不成立，一国的经济形势会变；一家公司的发展形式也会变；金融市场的结构也会发生变化。而这些变化往往会改变策略的表现，因此需要时刻考虑以上因素。</p>
</div>
<div id="选择一个好的量化平台" class="section level2">
<h2>选择一个好的量化平台</h2>
<p>选择一个合适的平台有以下判断标准</p>
<div id="你自身的编程能力" class="section level3">
<h3>你自身的编程能力</h3>
<p>总之就是避免使用Excel</p>
<p>总之，主流的平台都有自己的API，甚至自己的IDE。</p>
</div>
<div id="能否用同一套程序来回测和执行" class="section level3">
<h3>能否用同一套程序来回测和执行</h3>
<p>答案是看你的使用的平台，具体情况具体说。</p>
<p>总之，就是有钱的话，能够购买到商业平台，各种特性都支持，而开源的平台各有各的特点。</p>
</div>
<div id="does-the-platform-have-complex-event-processing" class="section level3">
<h3>Does the Platform Have Complex Event Processing</h3>
</div>
</div>
</div>
<div id="均值回归策略基础" class="section level1">
<h1>均值回归策略基础</h1>
<p>在金融时间序列中是否广泛存在均值回归现象呢？很遗憾，并不是，如果是的话，那这个世界就简单太多了。大部分的价格数据服从随机游走。少部分的价格数据是平稳的，他们有均值回归特性。</p>
<p>幸运的是，多个时间序列可能会存在协整关系，而针对存在协整关系的时间序列，我们的居住回归策略依然有其用武之地。</p>
<div id="均值回归和平稳性" class="section level2">
<h2>均值回归和平稳性</h2>
<p>数据的均值回归特性和平稳性是数据的两个方面，视角不同，所用的测试方法也不同。</p>
<p>一个时间序列的均值回归特性意味着，该序列在下一期的值和当期价格和平均价格的差成比例。我们用ADF检验对该特性进行检验，实际上是检验了比例变量的系数是否为0.</p>
<p>而从平稳性角度来看，一个时间序列是平稳的意味着，该时间序列的log值的方差相比于随即游走的方差增加的较慢。也就是说，他们的方差是一个关于时间<span class="math inline">\(t\)</span>的次线性函数。该次线性函数我们通常用<span class="math inline">\(\tau^{2H}\)</span>来逼近，其，<span class="math inline">\(\tau\)</span> is the so-called time separating two price measurements, <span class="math inline">\(H\)</span>是所谓的赫斯特指数，若时间序列是平稳的，则<span class="math inline">\(H\)</span>应当是小于0.5的（若序列是一个随即游走，则其应当等于0.5）。Variance Ratio检验可用来检验原假设：赫斯特指数是0.5。</p>
<div id="增广的df检验" class="section level3">
<h3>增广的DF检验</h3>
<p>我们使用一个线性模型来描述平稳的价格变化序列：</p>
<p><span class="math display">\[
\Delta y(t) = \lambda y(t-1)+\mu +\beta t +\alpha_1\Delta y(t-1) +\dots + \alpha_k \Delta y(t-k) +\epsilon_t
\]</span></p>
<p>其中：</p>
<p><span class="math inline">\(\Delta y(t) \equiv y(t) - y(t-1)\)</span></p>
<p>ADF检验实际上就是检验原假设：<span class="math inline">\(\lambda =0\)</span>.</p>
<p>若拒绝原假设意味着序列不是随机游走，当前期的y值对下一期的y值有影响。</p>
<p>检验统计量：</p>
<p><span class="math display">\[
\lambda/SE(\lambda)
\]</span></p>
<p>实际上，不用管这些，只管用就行了。</p>
<p><strong>Example: 均值回归中的ADF检验(Using Matlab)</strong></p>
<p>matlab 开源程序包提供了<code>adftest</code>函数来进行adf检验。</p>
<pre class="matlab"><code># 真用到matlab的时候再看手册不迟
results=adf(y,0,1)
prt(results)</code></pre>
</div>
<div id="赫斯特指数和方差比检验" class="section level3">
<h3>赫斯特指数和方差比检验</h3>
<p>The speed of diffusion can be calculated by the variance:</p>
<p><span class="math display">\[
Var(\tau) = &lt;|z(t+\tau) - z(t)|^{2}&gt;
\]</span></p>
<p><span class="math inline">\(z = log(y)\)</span>;</p>
<p><span class="math inline">\(\tau\)</span>:arbitrary time lag;</p>
<p><span class="math inline">\(&lt;\dots&gt;\)</span> : average over all <span class="math inline">\(t^{,}\)</span> s</p>
</div>
<div id="half-life-of-mean-reversion" class="section level3">
<h3>Half-Life of Mean Reversion</h3>
<div class="figure">
<img src="https://v2fy.com/asset/0i/ChineseBQB/011Dog_%E7%8B%97%F0%9F%90%B6BQB/%E7%8B%9700022-%E6%89%8B%E5%8A%A8%E7%8B%97%E5%A4%B4.gif" alt="" />
<p class="caption"><strong>半条命？？</strong></p>
</div>
<p>统计上的显著性实际上要求比较严格，一般来说，要求至少90%的显著性；而在实际应用中，哪怕显著性更低些，也不意味着我们的策略不能盈利。上面式子中的<span class="math inline">\(\lambda\)</span>参数还有另一种解释，即，it’s a measure of how long ti taks for a price to mean revert.</p>
<p>我们把本章最开始的那个线性模型取差分形式并用无穷小来逼近，即可得到以下形式(Ornstein-Uhlenbeck formula)：</p>
<p><span class="math display">\[
dy(t) = (\lambda y(t-1) + \mu)dt +d\epsilon 
\]</span></p>
<p><span class="math inline">\(d\epsilon\)</span> : 高斯分布的噪声。</p>
<p>巴拉巴拉，使用差分形式重写方程的好处在于其可以给出<span class="math inline">\(y(t)\)</span>的期望值的一个解析解。</p>
<p><span class="math display">\[
E(y(t)) = y_0 exp(\lambda t) - \mu / \lambda (1-exp(\lambda t))
\]</span></p>
<p>在一个均值回归（平稳）过程中，<span class="math inline">\(\lambda\)</span>是负的。如果我们发现其为正的，那么就不应当应用均值回归策略。另一点，如果<span class="math inline">\(\lambda\)</span>非常接近0那么，half-life将会非常的长，那么，在给定的时间里，我们将不能完成足够的交易轮次，这就意味着，该策略赚不了钱。</p>
<p><strong>Example: 2.4 计算均值回归策略中的Half Life</strong></p>
<blockquote>
<p>所以这是半条命还是半衰期。。。</p>
</blockquote>
<p><img src="https://v2fy.com/asset/0i/ChineseBQB/043Altman_%E5%A5%A5%E7%89%B9%E6%9B%BCBQB/%E5%A5%A5%E7%89%B9%E6%9B%BC00285-%E5%B0%8F%E5%B0%8F%E7%9A%84%E5%87%B9%E5%87%B8%E6%9B%BC%E8%84%91%E8%A2%8B%E8%A3%85%E6%BB%A1%E4%BA%86%E5%A4%A7%E5%A4%A7%E7%9A%84%E7%96%91%E6%83%91.jpg" /></p>
<p>之前的例子中，我们认识到USD.CAD在90%的显著性水平上是一个不平稳的序列，但这并不意味着我们不能对该序列使用均值回归策略。因为均值回归策略其实对数据的要求并没有那么高。我们在此计算出其Half Life of mean reversion 来决定其是否合适应用均值回归策略。</p>
<p><strong>因变量</strong>：<span class="math inline">\(y(t) - y(t-1)\)</span>;</p>
<p><strong>自变量</strong>: <span class="math inline">\(y(t-1)\)</span>。</p>
<p>跑个OLS回归。相应命令在<code>jplv7</code>包中，MATLAB的统计工具箱中的<code>regress</code>也可以实现。</p>
<pre class="matlab"><code>ylag = lag(y,1); % lag is a function in the jplv7
deltaY = y - ylag;
deltaY(1) = []; %Regression functions cannot handle the NaN in the first bar of the time series
ylag(1) = [];
regress_result = ols(deltaY, [ylag ones(size(ylag))]);
halflife=-log(2)/regress_results.beta(1);</code></pre>
</div>
<div id="一个线性的均值回归策略" class="section level3">
<h3>一个线性的均值回归策略</h3>
</div>
</div>
</div>
